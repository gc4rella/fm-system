import org.openbaton.catalogue.mano.common.monitoring.*
import org.openbaton.faultmanagement.fc.repositories.VRAlarmRepository
import org.openbaton.faultmanagement.fc.repositories.VNFAlarmRepository
import org.openbaton.catalogue.mano.record.VNFCInstance
import org.openbaton.faultmanagement.fc.policymanagement.interfaces.PolicyManager
import org.openbaton.faultmanagement.fc.interfaces.NFVORequestor
import org.openbaton.catalogue.mano.record.VirtualNetworkFunctionRecord
import org.openbaton.catalogue.mano.common.faultmanagement.VirtualizedResourceAlarmStateChangedNotification
import org.openbaton.catalogue.mano.common.faultmanagement.VNFAlarmStateChangedNotification
import org.openbaton.faultmanagement.fc.RecoveryAction
import org.openbaton.faultmanagement.fc.RecoveryActionStatus
import java.util.Date
import java.text.SimpleDateFormat
import java.text.DateFormat
import org.openbaton.catalogue.mano.descriptor.VirtualDeploymentUnit;
import org.openbaton.faultmanagement.ha.HighAvailabilityManager
import java.util.List
import java.util.Iterator
import org.openbaton.faultmanagement.fc.RecoveryActionType

global PolicyManager policyManager
global org.slf4j.Logger logger
global NFVORequestorWrapper nfvoRequestor
global HighAvailabilityManager highAvailabilityManager
global VRAlarmRepository vrAlarmRepository
global VNFAlarmRepository vnfAlarmRepository

declare VRAlarm
 @role(event)
 @expires(2m)
end

declare VNFAlarm
 @role(event)
 @expires(2m)
end



//----------------------------------------------- VirtualizedResource ALARMS -----------------------------------------------------

rule "Get a CRITICAL Virtualized Resource Alarm and switch to standby"

    when
        a : VRAlarm( thresholdId : thresholdId, hostname : managedObject, alarmState == AlarmState.FIRED,
        perceivedSeverity == PerceivedSeverity.CRITICAL)
        not RecoveryAction(status == RecoveryActionStatus.IN_PROGRESS)
    then
        logger.info("(VIRTUALIZATION LAYER) A CRITICAL alarm is received regarding the managedObject: " + hostname);
        VNFCInstance failedVnfcInstance = nfvoRequestor.getVNFCInstance(hostname);

        VirtualNetworkFunctionRecord vnfr = nfvoRequestor.getVirtualNetworkFunctionRecordFromVNFCHostname(hostname);

        VirtualDeploymentUnit vdu = nfvoRequestor.getVDU(vnfr,failedVnfcInstance.getId());

        logger.info("Switch to standby fired!");
        highAvailabilityManager.switchToRedundantVNFC(failedVnfcInstance,vnfr,vdu);

        RecoveryAction recoveryAction= new RecoveryAction(RecoveryActionType.SWITCH_TO_STANDBY,vnfr.getEndpoint(), vdu.getVimInstanceName().iterator().next() );
        recoveryAction.setStatus(RecoveryActionStatus.IN_PROGRESS);
        logger.debug("Recovery action in progress! :"+recoveryAction);
        insert(recoveryAction);
end

rule "A VR alarm is cleared"
    when
        VirtualizedResourceAlarmStateChangedNotification( currentThresholdId : triggerId, alarmState == AlarmState.CLEARED )
    then
        VRAlarm vrAlarm = vrAlarmRepository.changeAlarmState(currentThresholdId,AlarmState.CLEARED);
        logger.debug("\tThis vr alarm is cleared :" + vrAlarm);
        Iterable<VRAlarm> alarms = vrAlarmRepository.findAll();
        logger.debug("Current VR alarms:"+alarms);
end

rule "Save a VR Alarm"
    when
        a : VRAlarm()
    then
        VRAlarm vrAlarm = vrAlarmRepository.save(a);
        logger.debug("\tThis VR alarm is saved :" + vrAlarm);
        Iterable<VRAlarm> alarms = vrAlarmRepository.findAll();
        logger.debug("Current VR alarms:"+alarms);
end




//-------------------------------------------- VNF ALARMS ---------------------------------------------------------------


rule "Get a VNF Alarm from a VNFM"
    when
        vnfAlarm : VNFAlarm( vnfrId : vnfrId )
    then
        VirtualNetworkFunctionRecord vnfr = nfvoRequestor.getVirtualNetworkFunctionRecord(vnfrId);
        logger.debug("Got a VNFAlarm from the VNF manager: "+vnfr.getEndpoint());
end


rule "Save a VNFAlarm"
    when
        vnfAlarm : VNFAlarm()
    then
    VNFAlarm alarm = vnfAlarmRepository.save(vnfAlarm);
    logger.debug("Saved VnfAlarm: "+alarm);
end

rule "A VNF alarm is cleared"

    when
        VNFAlarmStateChangedNotification( thresholdId : thresholdId, alarmState == AlarmState.CLEARED )
    then
        VNFAlarm vnfAlarm = vnfAlarmRepository.changeAlarmState(thresholdId,AlarmState.CLEARED);
        logger.info("\tThis VNF alarm is cleared :" + vnfAlarm);
        Iterable<VNFAlarm> alarms = vnfAlarmRepository.findAll();
        logger.debug("Current VNF alarms:"+alarms);
end

rule "A VNF alarm is updated"

    when
        vascn : VNFAlarmStateChangedNotification( thresholdId : thresholdId, alarmState == AlarmState.UPDATED )
        vnfAlarmUpdated : VNFAlarm( perceivedSeverity == PerceivedSeverity.CRITICAL, vnfcIds : vnfcIds ) from vnfAlarmRepository.findFirstByThresholdId(thresholdId)
        vnfcId : String() from vnfcIds
    then
        logger.info("\tThis VNF alarm is updated :" + vnfAlarmRepository.changeAlarmState(thresholdId,AlarmState.UPDATED));

        VirtualNetworkFunctionRecord vnfr = nfvoRequestor.getVirtualNetworkFunctionRecord(vnfAlarmUpdated.getVnfrId());
        VNFCInstance vnfcInstance = nfvoRequestor.getVNFCInstanceById(vnfcId);
        VirtualDeploymentUnit vdu = nfvoRequestor.getVDU(vnfr,vnfcInstance.getId());

        logger.info("Switch to standby fired!");
        highAvailabilityManager.switchToRedundantVNFC(vnfcInstance,vnfr,vdu);

        RecoveryAction recoveryAction= new RecoveryAction(RecoveryActionType.SWITCH_TO_STANDBY,"generic", "vimname" );
        recoveryAction.setStatus(RecoveryActionStatus.IN_PROGRESS);
        logger.debug("Recovery action in progress! :"+recoveryAction);
end



rule "Got a critical VNF Alarm and execute a switch to standby if no action is ongoing on the vim"

    when
       vnfAlarm : VNFAlarm(  alarmState == AlarmState.FIRED, perceivedSeverity == PerceivedSeverity.CRITICAL, $vimName : vimName, vnfcIds : vnfcIds )
       vnfcId : String() from vnfcIds
       vnfcInstance : VNFCInstance( hostname : hostname) from nfvoRequestor.getVNFCInstanceById(vnfcId)
       activeVRAlarm : List( size == 0) from collect ( VRAlarm( alarmState != AlarmState.CLEARED ) from vrAlarmRepository.findByManagedObject(hostname))
       not ( VRAlarm(this after [0s,30s] vnfAlarm))
       not RecoveryAction(status == RecoveryActionStatus.IN_PROGRESS, vimName == $vimName)
    then

    //Get the vnfr
    logger.debug("Received vnf alarm: "+vnfAlarm);
    VirtualNetworkFunctionRecord vnfr = nfvoRequestor.getVirtualNetworkFunctionRecord(vnfAlarm.getVnfrId());

    //Get the vnfc failed (assuming only one vnfc is failed)
    //VNFCInstance vnfcInstance = nsrManager.getVNFCInstanceFromVnfr(vnfr,vnfAlarm.getVnfcIds().iterator().next());

    logger.info("(VNF LAYER) A CRITICAL alarm is received by the vnfc: "+vnfcInstance.getHostname());

    //Get the vdu of the failed VNFC
    VirtualDeploymentUnit vdu = nfvoRequestor.getVDU(vnfr,vnfcInstance.getId());

    logger.info("Heal fired!");
    highAvailabilityManager.executeHeal("serviceDown",vnfr.getParent_ns_id(),vnfr.getId(),vdu.getId(),vnfcInstance.getId());

    //Insert a new recovery action
    RecoveryAction recoveryAction= new RecoveryAction(RecoveryActionType.HEAL,vnfr.getEndpoint(),vnfAlarm.getVimName());
    recoveryAction.setStatus(RecoveryActionStatus.IN_PROGRESS);
    logger.debug("Recovery action in progress! :"+recoveryAction);
    insert(recoveryAction);
end
